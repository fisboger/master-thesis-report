\documentclass{report}
\usepackage{import}
\subimport{../../}{preamble.tex}
\standalonetrue
\begin{document}

% sample content
\section{CVE-2021-24086}
\label{sec:CVE-2021-24086}
According to Microsoft\cite{url:microsoft:cve-2021-24086} CVE-2021-24086 is a denial of service vulnerability with a CVSS:3.0 score of 7.5 / 6.5, that is a base score metrics of 7.5 and a temporal score metrics of 6.5. The vulnerability affects all supported versions of Windows and Windows Server. According to an accompanied blog post published by Microsoft
\cite{url:microsoft:cve-2021-24086-blog} at the same time as the patch was released, details that the vulnerable component is the Windows TCP/IP implementation, and that the vulnerability revolves around IPv6 fragmentation. The Security Update guide and the blog post also \todo{Figure out if this should be here}present a workaround that can be used to temporarily mitigate the vulnerability by disabling IPv6 fragmentation.

\subsection{Public information}
\label{sec:CVE-2021-24086:public-information}
Due to the \gls{mapp}\cite{url:microsoft:mapp} security software providers are given early access to vulnerability information. The provided information often include \gls{POC}s for vulnerabilities to be patched in order to aid security software providers in creating valid detections for exploitation of soon-to-be patched vulnerabilities. Due to \gls{mapp}, some security software providers publish relevant information regarding recently patched vulnerabilities. However, the information is usually very vague in details, and can therefore only aid in the initial exploration of the vulnerability. For CVE-2021-24086, both McAfee\cite{url:mcafee:cve-2021-24086} and Palo Alto\cite{url:palo-alto:cve-2021-24086} posted public information for defenders to consume. However, both articles contained very limited details, and they are therefore far from sufficient to reproduce the vulnerability. Before we try to rediscover the vulnerability, we have gathered the following publicly available information:

\begin{itemize}
    \item The vulnerability lies within the handling of fragmented packets in IPv6
    \item The relevant code lies within the \mintinline{c}{tcpip.sys} driver
    \item The root cause of the vulnerability is a NULL pointer dereference in \mintinline{c}{Ipv6ReassembleDatagram} of \mintinline{c}{tcpip.sys}
    \item The reassembled packet should contain around 0xFFFF (65535) bytes of extension headers, which is usually not possible
\end{itemize}
 
\subsection{Binary diffing}
The usage of binary diffing to gather information about patched vulnerabilities is well described in current research\cite{url:binary-diffing:1}\cite{url:binary-diffing:2}, and has been made popular and easy to do by tools such as Bindiff\cite{url:bindiff:homepage} and Diaphora\cite{url:diaphora:homepage}.
\\
\\
If we look at figure \ref{fig:tcpipsys-bindiff-primary-matched} we can compare the changes between the patched and non-patched binary, \mintinline{c}{tcpip.sys}. Looking at \mintinline{c}{tcpip!Ipv6pReassembleDatagram} we can see that the similarity factor is only 0.38 telling us that a significant amount of code has been changed.

\subimport{figures/}{tcpipsys-bindiff-primary-matched.tex}

Diving into the binary diff of \mintinline{c}{tcpip!Ipv6pReassembleDatagram} as seen on listing \ref{listing:diff:Ipv6pReassembleDatagram}, we can clearly see a change. The first many changes from line \emph{5-39} are simply register changes and other insignificant changes due to how the compiler works. However, on line \emph{41-42} a new comparison is made to ensure that the value of the register \mintinline{c}{edx} is less than 0xFFFF. This matches the statement given in \fullref{sec:CVE-2021-24086:public-information}, that the vulnerability is triggered by a packet of around 0xFFFF bytes.

\subimport{figures/}{diff-Ipv6pReassembleDatagram.tex}

Looking at the raw assembly without any knowledge of what the registers contain or what parameters are passed to the function can be very confusing. To make it easier for the reader to follow, listing \ref{listing:diff:Ipv6pReassembleDatagram-c} contains the annotated decompiled code of the vulnerable and patched \mintinline{c}{tcpip!Ipv6pReassembleDatagram} function. Here the patch is easy to spot, as the call to \mintinline{c}{tcpip!NetioAllocateAndReferenceNetBufferAndNetBufferList} is replaced with the check that we also observed in listing \ref{listing:diff:Ipv6pReassembleDatagram}. The check is there to ensure that the total packet size is less than 0xFFFF, which is the largest 16 bit value. The packet size is calculated on line \emph{4-6} using the fragmentable and unfragmentable parts of the reassembled packet.

\subimport{figures/}{diff-Ipv6pReassembleDatagram-c.tex}

At this stage of the vulnerability rediscovery process, the following requirements are now available:
\begin{itemize}
    \item We have to abuse IPv6 fragmentation in \mintinline{c}{tcpip!Ipv6pReassembleDatagram}
    \item We have to construct a single packet with around 0xFFFF bytes of extension headers
    \item We have to trigger a NULL pointer dereference somewhere in \mintinline{c}{tcpip!Ipv6pReassembleDatagram}
\end{itemize}

The next section will give a primer into how IPv6 fragmentation works to better understand how we can fulfill the above-mentioned requirements.

\subsection{IPv6 fragmentation primer}
When the size of a packet is larger than the \gls{mtu} of the outbound interface, IPv6 fragmentation is used. The \gls{mtu} of most standard network equipment and desktop computers are 1500 bytes. Therefore if you have an IPv6 packet that is larger than 1500 bytes, the packet must be fragmented. This is done by splitting the packet into a number of fragments, that each has to be decorated with the IPv6 fragment header. This header is a part of the specification for IPv6 Extension Headers\cite[sec. 4.5]{url:rfc:ipv6}. The IPv6 Extension Headers specification specify a number of headers situated between the IPv6 header and the upper-layer header in a packet.
The full list of extension headers can be seen in the following list:

\begin{enumerate}
    \item Hop-by-Hop Options
    \item \emph{Fragment}
    \item \emph{Destination Options}
    \item Routing
    \item Authentication
    \item Encapsulating Security Payload
\end{enumerate}

As mentioned in section \ref{sec:CVE-2021-24086:public-information}, the vulnerability is triggered when around 0xFFFF bytes of extension headers are present in the packet. Therefore, the following sections will describe both the \emph{Destination Options} and \emph{Fragment} extension headers in enough detail to support the exploitation of CVE-2021-24086.

\subsubsection{IPv6 Destination Options extension header}
IPv6 Destination Options are a way of defining options that should be handled by the destination node. In our case this node would be the device that we are trying to attack using CVE-2021-24086. The specification can be seen on \fullref{fig:ipv6-destination-options-header}. The header is essentially structured as a list of options, where it is up to the receiver of a packet to support certain options.

\subimport{figures/}{ipv6-destination-options-header.tex}

By default, only one option exist, the \emph{PadN option}\cite[sec. 4.2]{url:rfc:ipv6} which is used to create padding between two options. While this may not seem overly exciting, it is a very important part of how we can exploit CVE-2021-24086. Most other extension headers contain data that must be valid, such as routing options, which makes it hard to create a valid packet with around 0xFFFF bytes of extension headers. Destination Options does not have this limitation, as we can simply fill it with an arbitrary number of \emph{PadN} options.

\subsubsection{IPv6 Fragment extension header}
Moving on to the IPv6 Fragment extension header, which, as mentioned earlier, is a header placed when you split an IPv6 packet into smaller fragments. IPv6 fragments are mostly used to send packets larger than the configured \gls{mtu}, on either the sender or receiver side. The specification is detailed on figure \fullref{fig:ipv6-fragment-header}. The header contains an offset that points to where the fragment data fits into the entire packet.
\subimport{figures/}{ipv6-fragment-header.tex}
Every packet that is fragmented has an unique identification, as specified in \fullref{fig:ipv6-fragment-header}. According to the specification\cite[sec. 4.5]{url:rfc:ipv6}, this identification must be different than any other fragmented packet sent recently\footnote{Recently is very loosely defined by RFC 8200\cite{url:rfc:ipv6} as the \emph{"maximum likely lifetime of a packet, including transit time from source to destination and time spent awaiting reassembly with other fragments of the same packet."}\cite[sec. 4.5]{url:rfc:ipv6}}.
\\
\\
A packet destined to be fragmented goes through two different processes, fragmentation and reassembly. Fragmentation happens on the sender side whereas reassembly is handled by the recipient of the packet.

\paragraph{Fragmentation.} Fragmentation is done by the sender and is a fairly simple concept. Looking at figure \fullref{fig:ipv6-fragmentation}, it can be seen that an IPv6 packet contains two parts, an unfragmentable and a fragmentable part. The unfragmentable part is the IPv6 headers and the following two IPv6 extension headers, as they are processed by nodes en route:

\begin{itemize}
    \item Hop-by-Hop Options Headers
    \item Routing Header
\end{itemize}

The rest of the IPv6 packet, including the Destination Options header, is handled as the fragmentable part.

\paragraph{Reassembly.} Reassembling the fragmented packet is done by the receiver and is essentially the fragmentation process in reverse. So here the receiver will convert a number of fragments into a single packet that can be handled as a standard IPv6 packet. The split of a fragmented packet can be seen on figure \fullref{fig:ipv6-fragmentation}. Here it is easy to see that every fragment contains the unfragmentable part before any fragmented data.

\subimport{figures/}{ipv6-fragmentation.tex}

\subsection{Root-cause analysis}
\label{sec:CVE-2021-24086:root-cause}
At this point in the analysis the following relevant information has been presented to the reader:
\begin{enumerate}
    \item The vulnerability happens when \mintinline{c}{tcpip.sys} reassembles a fragmented packet
    \item The root cause of the vulnerability is a NULL pointer dereference in \mintinline{c}{Ipv6ReassembleDatagram} of \mintinline{c}{tcpip.sys}
    \item The packet should contain around 0xFFFF bytes of extension headers
    \item Extension headers can be present both in the unfragmentable and the unfragmentable part of the packet
    \item The \gls{mtu} limits how many bytes the unfragmentable part of the packet can contain
    \item The Destination Options extension header is a good candidate for reaching 0xFFFF bytes
    \item The Fragment extension header is needed to fragment the packet
\end{enumerate}

To understand the root-cause of CVE-2021-24086 we must first understand how the fragmentable and unfragmentable data of the fragmented packet is handled in \mintinline{c}{Ipv6pReceiveFragment} and \mintinline{c}{Ipv6ReassembleDatagram}. If we start with \mintinline{c}{Ipv6pReceiveFragment}, we can see that a packet is reassembled when the total length of all fragment matches the expected length of the packet:

\begin{listing}[H]
\begin{minted}[breaklines, linenos, breakanywhere]{c++}
RtlCopyMdlToBuffer(netBuffer->MdlChain, netBuffer->DataOffset, v55, netBuffer->DataLength, &v53);
IppReassemblyInsertFragment(datagram, ippReassemblyLocation, NewIrql);
IppIncreaseReassemblySize((struct_a1 *)(Blink + 20304), datagram, netBuffer->DataLength + 256, netBuffer->DataLength);

if ( datagram->dataLength == datagram->fragmentableLength ) {
    Ipv6pReassembleDatagram(a1, datagram, v21);
}
else {
    IppCheckReassemblyQuota((PKSPIN_LOCK)(Blink + 20304));
}
\end{minted}
\caption{\mintinline{c}{Ipv6pReceiveFragment} packet reassembly logic}
\label{listing:Ipv6pReceiveFragment:check}
\end{listing}

The check can be seen on line \emph{(5)} of listing \ref{listing:Ipv6pReceiveFragment:check} where line \emph{(6)} shows the call to \mintinline{c}{Ipv6ReassembleDatagram}. Once inside \mintinline{c}{Ipv6ReassembleDatagram} we can see that both the unfragmentable and fragmentable lengths are saved to local variables as seen on listing \ref{listing:Ipv6pReassembleDatagram:start}

\begin{listing}[H]
\begin{minted}[breaklines, linenos, breakanywhere]{c++}
void __fastcall Ipv6pReassembleDatagram(__int64 *a1, struct_datagram *datagram, KIRQL a3)
{
    int unfragmentableHeaderLength; // er9
    ulong BytesNeeded; // [rsp+A8h] [rbp+10h]
    int length; // [rsp+B8h] [rbp+20h]

    ...

    unfragmentableHeaderLength = datagram->unfragmentableHeaderLength;
    length = unfragmentableHeaderLength + datagram->fragmentableLength;
    BytesNeeded = unfragmentableHeaderLength + 40;

    ...
}
\end{minted}
\caption{\mintinline{c}{Ipv6pReassembleDatagram} length calculation}
\label{listing:Ipv6pReassembleDatagram:start}
\end{listing}

To understand the root cause, it is important to understand what will happen if the unfragmentable part of the header contains around 0xFFFF bytes. The calculation of \mintinline{c}{BytesNeeded} on line \emph{(11)} also shows why it is only necessary to have \emph{around} 0xFFFF bytes in the unfragmentable part, as 40 is added to the length of the unfragmentable part of the header to become the \mintinline{c}{BytesNeeded}.
\\
\\
Tracking down where \mintinline{c}{BytesNeeded} is used leads us to the code found in listing \ref{listing:Ipv6pReassembleDatagram:netbuffer-null-reference}. This listing contains the code for obtaining a buffer to store the data for the unfragmentable part of the header. As it can be seen on line \emph{(9)} and \emph{(19)}, this is where the \mintinline{c}{BytesNeeded} variable is used.

\begin{listing}[H]
\begin{minted}[breaklines, linenos, breakanywhere]{c++}
NetBufferList = (_NET_BUFFER_LIST *)NetioAllocateAndReferenceNetBufferAndNetBufferList(IppReassemblyNetBufferListsComplete, datagram, 0i64, 0i64, 0, 0);
if ( !NetBufferList )
{
    ...
    goto failure;
}

netBuffer = NetBufferList->FirstNetBuffer;
if ( NetioRetreatNetBuffer(netBuffer, (unsigned __int16)BytesNeeded, 0) < 0 )
{
    IppRemoveFromReassemblySet((PKSPIN_LOCK)(v7 + 20304), (__int64)datagram, a3);
    NetioDereferenceNetBufferList(NetBufferList, 0i64);

    ...

    goto memory_failure;
}

buffer = NdisGetDataBuffer(netBuffer, BytesNeeded, 0i64, 1u, 0);
\end{minted}
\caption{\mintinline{c}{Ipv6pReassembleDatagram} NetBuffer NULL pointer dereference logic}
\label{listing:Ipv6pReassembleDatagram:netbuffer-null-reference}
\end{listing}

The logic for listing \ref{listing:Ipv6pReassembleDatagram:netbuffer-null-reference} can be explained as such:
\begin{enumerate}
  \item The NetBufferList is retrieved by \mintinline{c}{NetioAllocateAndReferenceNetBufferAndNetBufferList} and checked for validity
  \item The first \mintinline{c}{NetBuffer} is retrieved using \mintinline{c}{NetioRetreatNetBuffer}
  \begin{itemize}
    \item Notice the cast to a unsigned 16 bit integer on line \emph{(9)} wich will truncate the \mintinline{c}{BytesNeeded}.
  \end{itemize}
  \item \mintinline{c}{NdisGetDataBuffer} is used to retrieve a buffer.
  \begin{itemize}
    \item Notice that \mintinline{c}{BytesNeeded} is \emph{not} cast in this call on line \emph{(10)}.
  \end{itemize}
\end{enumerate}

Now the question is, what happens when \mintinline{c}{NetioRetreatNetBuffer} is invoked with a smaller value than \mintinline{c}{NdisGetDataBuffer}? The answer to that question is that \mintinline{c}{NdisGetDataBuffer} returns NULL. Later on in the function this buffer, which is NULL, is written to which will demonstrate that this indeed is a NULL pointer dereference. At this point we are presented with the root cause of the vulnerability, and can therefore move on to the process of triggering the vulnerability by sending a packet with about 0xFFFF extension headers in the unfragmentable part of the packet.

\subsection{Triggering the vulnerability}
\label{cve-2021-24086:triggering}
To trigger CVE-2021-24086 a raw IPv6 packet has to be constructed which might not conform completely with the IPv6 specification. For this reason, it was decided to build the PoC using a combination of custom Python code and Scapy\cite{url:ipv6:scapy}, which is a Python package used to craft network packets.
\\
\\
As explained in \fullref{sec:CVE-2021-24086:root-cause} the unfragmentable part of the Ipv6 packet header is constrained by the size of the MTU, which is usually around 1500 bytes. In 2012 Antonios Atlasis highlighted a number of security issues present in implementations of IPv6 across different operating systems such as Windows, CentOS, Ubuntu and others\cite{url:ipv6:abusing-ipv6}. In his paper, Antonios explain how two create \emph{nested fragments} that allow one to embed a fragment inside another fragment. \fullref{fig:ipv6:nested-fragments} shows how such a packet can be constructed.

\subimport{figures/}{ipv6-nested-fragments.tex}

If we combine all the knowledge gained from the previous section the following IPv6 packet structure should produce a \gls{POC} that can be used to trigger CVE-2021-24086:

\begin{enumerate}
    \item Create a long packet, $packet_1$ with around 0xFFFF bytes of \emph{Destination Option} header data. This packet should be fragmented using IPv6 fragments.
    \item Construct $packet_2$ as an IPv6 packet containing one fragment header with an unique fragment header id. The packet should also contain some data.
    \item Add a fragment header to the end of the headers for $packet_1$ with the fragment header id set to the fragment header id used in $packet_2$.
    \item Send all fragments for $packet_1$
    \item Send $packet_2$ which should trigger a reassembly of the nested fragments leading to \gls{dos}
\end{enumerate}

Pseudo-code for this \gls{POC} can be seen in listing \ref{listing:poc:pseudo}

\begin{listing}[H]
\begin{minted}[breaklines, linenos, breakanywhere]{python}
first_fragment_id = random.randint()
second_fragment_id = random.randint()

packet1 = IPv6Header + IPv6ExtHdrDestOpt1 + IPv6ExtHdrDestOpt2 + IPv6ExtHdrDestOpt.. + IPv6ExtHdrDestOptN
packet1 += IPv6ExtHdrFragment(fragment_header_id = second_fragment_id)
packet1 += UDPPacket

packet1_fragments = fragment(packet1)

packet2 = IPv6Header + IPv6ExtHdrFragment(fragment_header_id = second_fragment_id) + 'Dummy data'

send(packet1_fragments)
send(packet2)
\end{minted}
\caption{Pseudo-code \gls{POC} for triggering CVE-2021-24086}
\label{listing:poc:pseudo}
\end{listing}

An implementation of the pseudo-code can be found in Appendix \ref{appendix:poc}. As the \gls{POC} is hardcoded to run against the IPv6 multicast address, \emph{ff02::1}, it will run against any machines present on the current IPv6 subnet. Running the \gls{POC} with a vulnerable Windows machine present will result in a \gls{BSOD} on the vulnerable machine as seen on \fullref{fig:poc:bsod}, where it can also be seen that the crash originated from \mintinline{c}{tcpip.sys}.

\subimport{figures/}{bsod.tex}

If the same \gls{POC} is run with a debugger attached, we get the output seen on listing \ref{listing:poc:windbg} showing the details around the crash.

\subimport{figures/}{windbg-stacktrace.tex}

Examining the stacktrace seen in listing \ref{listing:poc:windbg} we can see that the crash happens at \mintinline{c}{Ipv6pReassembleDatagram+0x14f} coming from \mintinline{c}{Ipv6pReceiveFragment+0x84a} which matches the root-cause found in \fullref{sec:CVE-2021-24086:root-cause}. Line \emph{(1)} also highlights that this is infact a NULL pointer dereference as the instruction \mintinline{c}{moveups} attempts to write to the address NULL.
% \subimport{}{subsubsection.tex}

\end{document}