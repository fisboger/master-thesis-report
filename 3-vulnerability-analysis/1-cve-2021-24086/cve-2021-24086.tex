\documentclass{report}
\usepackage{import}
\subimport{../../}{preamble.tex}
\standalonetrue
\begin{document}

% sample content
\section{CVE-2021-24086}
\label{sec:CVE-2021-24086}
According to Microsoft\cite{url:microsoft:cve-2021-24086} CVE-2021-24 086 is a denial of service vulnerability with a CVSS:3.0 score of 7.5 / 6.5, that is a base score metrics of 7.5 and a temporal score metrics of 6.5. The vulnerability affects all supported versions of Windows and Windows Server. According to an accompanied blog post published by Microsoft
\cite{url:microsoft:cve-2021-24086-blog} at the same time as the patch was released, details that the vulnerable component is the Windows TCP/IP implementation, and that the vulnerability revolves around IPv6 fragmentation. The Security Update guide and the blog post also \todo{Figure out if this should be here}present a workaround that can be used to temporarily mitigate the vulnerability by disabling IPv6 fragmentation.

\subsection{Public information}
\label{sec:CVE-2021-24086:public-information}
Due to the \gls{mapp}\cite{url:microsoft:mapp} security software providers are given early access to vulnerability information. This information often include \gls{poc}s for vulnerabilities to be patched, in order to aid security software providers to create valid detections for exploitation of soon-to-be patched vulnerabilities. Due to \gls{mapp}, some security software providers publish relevant information regarding recently patched vulnerabilities. However, the information is usually very vague in details, and can therefore only aid in the initial exploration of the vulnerability. For CVE-2021-24086, both McAfee\cite{url:mcafee:cve-2021-24086} and Palo Alto\cite{url:palo-alto:cve-2021-24086} posted public information about CVE-2021-24086. However, both articles contained very limited details, and is therefore far from sufficient to reproduce the vulnerability. Before trying to rediscover the vulnerability, the following information is available:

\begin{itemize}
    \item The vulnerability lies within the handling om fragmented packets in IPv6
    \item The relevant code lies within the \mintinline{c}{tcpip.sys} drivers
    \item The root cause of the vulnerability is a NULL pointer dereference in \mintinline{c}{Ipv6ReassembleDatagram} of \mintinline{c}{tcpip.sys}
    \item The reassembled packet should contain around 0xFFFF (65535) bytes of extension headers, which is usually not possible
\end{itemize}
 
\subsection{Binary diffing}
The usage of binary diffing to gather information about patched vulnerabilities is well described in current research\cite{url:binary-diffing:1}\cite{url:binary-diffing:2}, and has been made popular and easy to do by tools such as Bindiff\cite{url:bindiff:homepage} and Diaphora\cite{url:diaphora:homepage}. \todo{write a little about how bindiffing works. Or don't idc.}
\\
\\
If we look at figure \ref{fig:tcpipsys-bindiff-primary-matched} we can compare the function changes of the patched and not-patched \mintinline{c}{tcpip.sys}. Looking at \mintinline{c}{tcpip!Ipv6pReassembleDatagram} we can see that the similarity factor is only 0.38 telling us that a significant amount of code has been changed.

\subimport{figures/}{tcpipsys-bindiff-primary-matched.tex}

Diving into the binary diff of \mintinline{c}{tcpip!Ipv6pReassembleDatagram} as seen on listing \ref{listing:diff:Ipv6pReassembleDatagram}, we can clearly see a change. The first many changes from line \emph{5-39} are simply register changes and other insignificant changes due to how the compiler works. However, on line \emph{41-42} a new comparison is made to ensure that the value of the register \mintinline{c}{edx} is less than 0xFFFF. This matches the statement given in \fullref{sec:CVE-2021-24086:public-information}, that the vulnerability is triggered by a packet of around 0xFFFF bytes.

\subimport{figures/}{diff-Ipv6pReassembleDatagram.tex}

Looking at the raw assembly without any knowledge of what the registers contain or what parameters are passed to the function can be very confusing. To make it easier for the reader to follow, listing \ref{listing:diff:Ipv6pReassembleDatagram-c} contains the annotated decompiled code of the vulnerable and patched \mintinline{c}{tcpip!Ipv6pReassembleDatagram} function. Here the patch is easy to spot, as the call to \mintinline{c}{tcpip!NetioAllocateAndReferenceNetBufferAndNetBufferList} is replaced with the check that we also observed in listing \ref{listing:diff:Ipv6pReassembleDatagram}. The check is there to ensure that the total packet size is less than 0xFFFF, which is the largest 16 bit value. The packet size is calculated on line \emph{4-6} using the fragmentable and unfragmentable parts of the reassembled packet.

\subimport{figures/}{diff-Ipv6pReassembleDatagram-c.tex}

At this stage of the vulnerability rediscovery process, the following requirements are now available:
\begin{itemize}
    \item We have to abuse IPv6 fragmentation in \mintinline{c}{tcpip!Ipv6pReassembleDatagram}
    \item We have to construct a single packet with around 0xFFFF bytes of extension headers
    \item We have to trigger a null dereference somewhere in \mintinline{c}{tcpip!Ipv6pReassembleDatagram}
\end{itemize}

The next section will give a primer into how IPv6 fragmentation works to better understand how we can fulfill the above-mentioned requirements.

\subsection{IPv6 fragmentation primer}
When the size of a packet is larger than the \gls{mtu} of the outbound interface, IPv6 fragmentation is used. The \gls{mtu} of most standard network equipment and desktop computers is 1500 bytes. Therefore if you have an IPv6 packet that is larger than 1500 bytes, the packet must be fragmented. This is done by splitting the packet into a number of fragments, that each has to be decorated with the IPv6 fragment header. This header is a part of the specification for IPv6 Extension Headers\cite[sec. 4.5]{url:rfc:ipv6}. The IPv6 Extension Headers specification specify a number of headers situated between the IPv6 header and the upper-layer header in a packet.
The full list of extension headers can be seen in the following list:

\begin{enumerate}
    \item Hop-by-Hop Options
    \item \emph{Fragment}
    \item \emph{Destination Options}
    \item Routing
    \item Authentication
    \item Encapsulating Security Payload
\end{enumerate}

As mentioned in section \ref{sec:CVE-2021-24086:public-information}, the vulnerability is triggered when around 0xFFFF bytes of extension headers are present in the packet. Therefore, the following sections will describe both the \emph{Destination Options} and \emph{Fragment} extension headers in enough detail to support the exploitation of CVE-2021-24086.

\subsubsection{IPv6 Destination Options extension header}
IPv6 Destination Options are a way of defining options that should be handled by the destination node. In our case this would be the device that we are trying to attack using CVE-2021-24086. The specification can be seen on \fullref{fig:ipv6-destination-options-header}. The header is essentially structured as a list of options, where it is up to the receiver of a packet to support certain options.

\subimport{figures/}{ipv6-destination-options-header.tex}

By default, only one option exist, the \emph{PadN option}\cite[sec. 4.2]{url:rfc:ipv6} which is used to create padding between two options. While this may not seem overly exciting, it is a very important part of how we can exploit CVE-2021-24086. Most other extension headers contain data that must be valid, such as routing options, which makes it hard to create a valid packet with around 0xFFFF bytes of extension headers. Destination Options does not have this limitation, as we can simply fill it with an arbitrary number of \emph{PadN} options.

\subsubsection{IPv6 Fragment extension header}
Moving on to the IPv6 Fragment extension header, which, as mentioned earlier, is a header placed when you split an IPv6 packet into smaller fragments. IPv6 fragments are mostly used to send packets larger than the configured \gls{mtu}, on either the sender or receiver side. The specification is detailed on figure \fullref{fig:ipv6-fragment-header}. The header contains an offset that points to where the fragment data fits into the entire packet.
\subimport{figures/}{ipv6-fragment-header.tex}
Every packet that is fragmented has an unique identification, as specified in \fullref{fig:ipv6-fragment-header}. According to the specification\cite[sec. 4.5]{url:rfc:ipv6}, this identification must be different than any other fragmented packet sent recently\footnote{Recently is very loosely defined by RFC 8200\cite{url:rfc:ipv6} as the \emph{"maximum likely lifetime of a packet, including transit time from source to destination and time spent awaiting reassembly with other fragments of the same packet."}\cite[sec. 4.5]{url:rfc:ipv6}}.
\\
\\
A packet destined to be fragmented goes through two different processes, fragmentation and reassembly. Fragmentation happens on the sender side whereas reassembly is handled by the recipient of the packet.

\paragraph{Fragmentation} is done by the sender and is a fairly simple concept. Looking at figure \fullref{fig:ipv6-fragmentation}, it can be seen that an IPv6 packet contains two parts, an unfragmentable and a fragmentable part. The unfragmentable part is the IPv6 headers and the following two IPv6 extension headers, as they are processed by nodes en route:

\begin{itemize}
    \item Hop-by-Hop Options Headers
    \item Routing Header
\end{itemize}

The rest of the IPv6 packet, including the Destination Options header, is handled as a fragmentable part.

\paragraph{Reassembly} Reassembling the fragmented packet is done by the receiver and is essentially the fragmentation process in reverse. So here the receiver will convert a number of fragments into a single packet that can be handled as a standard IPv6 packet. The split of a fragmented packet can be seen on figure \fullref{fig:ipv6-fragmentation}. Here it is easy to see that every fragment contains the unfragmentable part before any fragmented data.

\subimport{figures/}{ipv6-fragmentation.tex}
% As the purpose of this fragmentation primer is to explain concepts needed to understand CVE-2021-24086 and afterwards building a \gls{poc} exploit, full fragmentation and  details will not be explained.
% TODO: Maybe keep the above somewhere?

\subsection{Root-cause analysis}
At this point in the analysis the following relevant information has been presented to the reader:
\begin{enumerate}
    \item The vulnerability happens when \mintinline{c}{tcpip.sys} reassembles a fragmented packet
    \item The root cause of the vulnerability is a NULL pointer dereference in \mintinline{c}{Ipv6ReassembleDatagram} of \mintinline{c}{tcpip.sys}
    \item The packet should contain around 0xFFFF bytes of extension headers
    \item Extension headers can be present both in the unfragmentable and the unfragmentable part of the packet
    \item The \gls{mtu} limits how many bytes the unfragmentable part of the packet can contain
    \item The Destination Options extension header is a good candidate for reaching 0xFFFF bytes
    \item The Fragment extension header is needed to fragment the packet
\end{enumerate}

To understand the root-cause of CVE-2021-24086 we must first understand how the fragmentable and unfragmentable data of the fragmented packet is handled in \mintinline{c}{Ipv6pReceiveFragment} and \mintinline{c}{Ipv6ReassembleDatagram}. If we start with \mintinline{c}{Ipv6pReceiveFragment}, we can see that a packet is reassembled when the total length of all fragment matches the expected length of the packet:

\begin{listing}[H]
\begin{minted}[breaklines, linenos, breakanywhere]{c++}
RtlCopyMdlToBuffer(netBuffer->MdlChain, netBuffer->DataOffset, v55, netBuffer->DataLength, &v53);
IppReassemblyInsertFragment(datagram, ippReassemblyLocation, NewIrql);
IppIncreaseReassemblySize((struct_a1 *)(Blink + 20304), datagram, netBuffer->DataLength + 256, netBuffer->DataLength);

if ( datagram->dataLength == datagram->fragmentableLength ) {
    Ipv6pReassembleDatagram(a1, datagram, v21);
}
else {
    IppCheckReassemblyQuota((PKSPIN_LOCK)(Blink + 20304));
}
\end{minted}
% \caption{\mintinline{c}{Ipv6pReceiveFragment} packet reassembly check}
% TODO: Decide if caption should be removed or not
\label{listing:diff:Ipv6pReceiveFragment}
\end{listing}

The check can be seen on line \emph{(5)} of Listing \ref{listing:diff:Ipv6pReceiveFragment} where line \emph{(6)} shows the call to \mintinline{c}{Ipv6ReassembleDatagram}. Once inside \mintinline{c}{Ipv6pReceiveFragment} we can see that both the unfragmentable and fragmentable lengths are saved to local variables:

\begin{listing}[H]
\begin{minted}[breaklines, linenos, breakanywhere]{c++}
void __fastcall Ipv6pReassembleDatagram(__int64 a1, struct_datagram *datagram, char a3)
{
    int unfragmentableHeaderLength; // er9
    ULONG BytesNeeded; // [rsp+A8h] [rbp+10h]
    int length; // [rsp+B8h] [rbp+20h]

    ...

    unfragmentableHeaderLength = datagram->unfragmentableHeaderLength;
    length = unfragmentableHeaderLength + datagram->fragmentableLength;
    BytesNeeded = unfragmentableHeaderLength + 40;

    ...
}
\end{minted}
\label{listing:diff:Ipv6pReassembleDatagram-start}
% \caption{\mintinline{c}{Ipv6pReceiveFragment} packet reassembly check}
% TODO: Decide if caption should be removed or not
\end{listing}

\subsection{Triggering the vulnerability}

% \subimport{}{subsubsection.tex}

\end{document}